{% from "enum_macros.tmpl" import enum_decl -%}

class {{struct.name}} {
 public:
  using Data_ = internal::{{struct.name}}_Data;

  // TODO(yzshen): Remove Reader.
  using Reader = {{struct.name}}_Reader;

{#--- Enums #}
{%- for enum in struct.enums -%}
  {{enum_decl(enum)|indent(2)}}
{%- endfor %}

{#--- Constants #}
{%- for constant in struct.constants %}
{%-   if constant.kind|is_integral_kind %}
  static const {{constant.kind|cpp_pod_type}} {{constant.name}} = {{constant|constant_value}};
{%-   else %}
  static const {{constant.kind|cpp_pod_type}} {{constant.name}};
{%-   endif %}
{%- endfor %}

  static {{struct.name}}Ptr New();

  template <typename U>
  static {{struct.name}}Ptr From(const U& u) {
    return mojo::TypeConverter<{{struct.name}}Ptr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, {{struct.name}}>::Convert(*this);
  }

  {{struct.name}}();
  ~{{struct.name}}();

{%  if struct|is_cloneable_kind %}
  {{struct.name}}Ptr Clone() const;
{%- endif %}
  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether typemapped native types
  // support operator==.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, {{struct.name}}>::value>::type* = nullptr>
  bool Equals(const T& other) const {
  {%-  for field in struct.fields %}
    if (!mojo::internal::ValueTraits<{{field.kind|cpp_wrapper_type}}>::Equals(this->{{field.name}}, other.{{field.name}}))
      return false;
  {%-  endfor %}
    return true;
  }

{#--- Struct members #}
{%  for field in struct.fields %}
{%-   set type = field.kind|cpp_wrapper_type %}
{%-   set name = field.name %}
  {{type}} {{name}};
{%- endfor %}
};

{# TODO(yzshen): Redo the Reader interface. #}
{# NOTE: Generated Reader instances are intentionally cheap to copy and devoid
   of heap allocations. They should stay this way. #}
// TODO(yzshen): Remove this.
class {{struct.name}}_Reader {
 public:
  {{struct.name}}_Reader(internal::{{struct.name}}_Data* data,
                         mojo::internal::SerializationContext* context);

{%-   for pf in struct.packed.packed_fields_in_ordinal_order %}
{%-     set kind = pf.field.kind -%}
{%-     set name = pf.field.name -%}
{%-     if kind|is_nullable_kind %}
  bool has_{{name}}() const;
{%-     endif %}
{%-     if kind|is_struct_kind and not kind|is_native_only_kind %}
  {{kind|get_name_for_kind}}_Reader {{name}}() const;
{%-     elif kind|is_string_kind %}
  base::StringPiece {{name}}() const;
{%-     elif kind|is_union_kind %}
  // TODO(rockot): Support reading unions. ({{name}}() omitted)
{%-     elif kind|is_object_kind %}
  // TODO(rockot): Support reading other object kinds. ({{name}}() omitted)
{%-     elif kind|is_any_handle_kind %}
  // TODO(rockot): Support reading handles. ({{name}}() omitted)
{%-     elif kind|is_interface_kind %}
  // TODO(rockot): Support reading interfaces. ({{name}}() omitted)
{%-     elif kind|is_interface_request_kind %}
  // TODO(rockot): Support reading interface requests. ({{name}}() omitted)
{%-     elif kind|is_associated_kind %}
  // TODO(rockot): Support reading associated kinds. ({{name}}() omitted)
{%-     elif kind|is_enum_kind %}
  {{kind|cpp_result_type}} {{name}}() const {
    return static_cast<{{kind|cpp_result_type}}>(data_->{{name}});
  }
{%-     else %}
  {{kind|cpp_result_type}} {{name}}() const { return data_->{{name}}; }
{%-     endif %}
{%-   endfor %}

 private:
  internal::{{struct.name}}_Data* data_;
  mojo::internal::SerializationContext* context_;
};
