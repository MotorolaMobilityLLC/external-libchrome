{%- import "struct_macros.tmpl" as struct_macros %}
{%- set mojom_type = struct|get_qualified_name_for_kind %}
{%- set data_type = struct|get_qualified_name_for_kind(internal=True) %}

template <>
struct StructTraits<{{mojom_type}}, {{mojom_type}}Ptr> {
  static bool IsNull(const {{mojom_type}}Ptr& input) { return !input; }

{%- for field in struct.fields %}
{%-   set return_ref = field.kind|is_object_kind or
                       field.kind|is_any_handle_kind or
                       field.kind|is_interface_kind or
                       field.kind|is_associated_kind %}
{%-   if return_ref %}
  static decltype({{mojom_type}}::{{field.name}})& {{field.name}}(
      {{mojom_type}}Ptr& input) {
    return input->{{field.name}};
  }
  static const decltype({{mojom_type}}::{{field.name}})& {{field.name}}(
      const {{mojom_type}}Ptr& input) {
    return input->{{field.name}};
  }
{%-   else %}
  static decltype({{mojom_type}}::{{field.name}}) {{field.name}}(
      const {{mojom_type}}Ptr& input) {
    return input->{{field.name}};
  }
{%-   endif %}
{%- endfor %}

  static bool ReadFromRawData({{data_type}}* input,
                              {{mojom_type}}Ptr* output,
                              internal::SerializationContext* context);
};

namespace internal {

template <typename MaybeConstUserType>
struct Serializer<{{mojom_type}}Ptr, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<{{mojom_type}}, UserType>;

  static size_t PrepareToSerialize(MaybeConstUserType& input,
                                   SerializationContext* context) {
    if (CallIsNullIfExists<Traits>(input))
      return 0;
    {{struct_macros.get_serialized_size(struct, "Traits::%s(input)", "context",
                                        True)|indent(2)}}
    return size;
  }

  static void Serialize(MaybeConstUserType& input,
                        Buffer* buffer,
                        {{data_type}}** output,
                        SerializationContext* context) {
    if (!CallIsNullIfExists<Traits>(input)) {
      {{struct_macros.serialize(struct, struct.name ~ " struct",
                                "Traits::%s(input)", "result", "buffer",
                                "context", True)|indent(4)}}
      *output = result;
    } else {
      *output = nullptr;
    }
  }

  static bool Deserialize({{data_type}}* input,
                          UserType* output,
                          SerializationContext* context) {
    return ReadCaller<Traits, HasReadFromRawDataMethod<Traits>::value>::Run(
        input, output, context);
  }


 public:
  template <typename Traits, bool use_read_from_raw_data>
  struct ReadCaller;

  template <typename Traits>
  struct ReadCaller<Traits, false> {
    static bool Run({{data_type}}* input,
                    UserType* output,
                    SerializationContext* context) {
      {{mojom_type}}_Reader reader(input, context);
      return Traits::Read(reader, output);
    }
  };

  template <typename Traits>
  struct ReadCaller<Traits, true> {
    static bool Run({{data_type}}* input,
                    UserType* output,
                    SerializationContext* context) {
      return Traits::ReadFromRawData(input, output, context);
    }
  };
};

}  // namespace internal
